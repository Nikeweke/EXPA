# Big O

> https://habr.com/ru/post/444594/

### Описание
`Big O` нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени. Тема для многих пугающая, программисты избегающие разговоров о «времени порядка N» обычное дело.

### Итог 

* Получение элемента коллекции это **O(1)**. Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет **O(1)**
* Перебор коллекции это **O(n)**
* Вложенные циклы по той же коллекции это **O(n^2)**
* Разделяй и властвуй (Divide and Conquer) всегда **O(log n)**
* Итерации которые используют Divide and Conquer это O**(n log n)**



### Алгоритм с оценкой - `O(1)`

В этом алгоритме будет постоянно 1 операция(подстановка индекса чтобы вытащить значение), даже если в массиве будет - 1000 элементов, по-этому `О` будет - `O(1)`
```
const nums = [1,2,3,4,5];
nums[0] // 1
```

> O(1) можно прочитать как «сложность порядка 1» (order 1), или «алгоритм выполняется за постоянное/константное время» (constant time).
>  O(1) алгоритмы самые эффективные.


### Алгоритм с оценкой - `O(n)`

Тут нужно перебрать все элементы из массива, которых `n` кол-во. Так же такой тип алгоритмов называют «линейными» или что алгоритм «линейно масштабируется».

```js
const nums = [1,2,3,4,5];
let sum = 0;
for(let num of nums){
	sum += num;
}
```

### Из `O(n)` в `O(1)`

Такой алгоритм гораздо эффективнее O(n), более того он выполняется за «постоянное/константное время», т.е. это O(1).

Фактически операций не одна: нужно получить длину массива, получить последний элемент, выполнить умножение и деление. Разве это не O(3) или что-нибудь такое? В Big O нотации фактическое кол-во шагов не важно, важно что алгоритм выполняется за константное время.

Алгоритмы с константным временем это всегда O(1). Тоже и с линейными алгоритмами, фактически операций может быть O(n+5), в Big O нотации это O(n).

```js
onst sumContiguousArray = function(ary){
	//get the last item
	const lastItem = ary[ary.length - 1];
	//Gauss's trick
	return lastItem * (lastItem + 1) / 2;
}
const nums = [1,2,3,4,5];
const sumOfArray = sumContiguousArray(nums);
```

### Алгоритм с оценкой - `O(n^2)`

Это функция которая проверяет массив на наличие дублей. Решение с вложенным циклом:

```js
onst hasDuplicates = function (num) {
    //loop the list, our O(n) op
    for (let i = 0; i < nums.length; i++) {
        const thisNum = nums[i];
        //loop the list again, the O(n^2) op
        for (let j = 0; j < nums.length; j++) {
            //make sure we're not checking same number
            if (j !== i) {
                const otherNum = nums[j];
                //if there's an equal value, return
                if (otherNum === thisNum) return true;
            }
        }
    }
    //if we're here, no dups
    return false;
}
const nums = [1, 2, 3, 4, 5, 5];
hasDuplicates(nums);//true
```

### Алгоритм с оценкой - `O(log n)`

Т.е. в худшем случае делаем столько операций, сколько раз можем разделить массив на две части. Например, сколько раз мы можем разделить на две части массив из 4 элементов? 2 раза. А массив из 8 элементов? 3 раза. Т.е. кол-во делений/операций = log2(n) (где n кол-во элементов массива).
